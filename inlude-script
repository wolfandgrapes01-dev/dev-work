import os
import re
from collections import defaultdict
from concurrent.futures import ThreadPoolExecutor
from tqdm import tqdm
import io

# --------------------------
# è¨­å®š
# --------------------------
root_dir = r"C:\path\to\your\root"  # ãƒ«ãƒ¼ãƒˆãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªï¼ˆå®Ÿãƒ‘ã‚¹ã«å·®ã—æ›¿ãˆã¦ãã ã•ã„ï¼‰
project_name = "ProjectA"            # è§£æå¯¾è±¡ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆ
extensions = ('.cpp', '.c', '.h', '.hpp')
include_pattern = re.compile(r'#include\s+[<"](.+?)[>"]')

# --------------------------
# 1ï¸âƒ£ ãƒ•ã‚¡ã‚¤ãƒ«ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ä½œæˆï¼ˆroot ä¸‹ã®å…¨ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ç™»éŒ²ï¼‰
# --------------------------
file_index = defaultdict(list)
for dirpath, dirnames, filenames in os.walk(root_dir):
    dirnames[:] = [d for d in dirnames if d.lower() != ".svn"]
    for filename in filenames:
        if filename.endswith(extensions):
            file_index[filename].append(os.path.abspath(os.path.join(dirpath, filename)))

# --------------------------
# 2ï¸âƒ£ ProjectA/src ä¸‹ã®è§£æå¯¾è±¡ãƒ•ã‚¡ã‚¤ãƒ«ã‚’åé›†ï¼ˆãƒˆãƒƒãƒ—ãƒ¬ãƒ™ãƒ«ï¼‰
# --------------------------
project_a_src = os.path.join(root_dir, project_name, "src")
top_files = []
for dirpath, dirnames, filenames in os.walk(project_a_src):
    dirnames[:] = [d for d in dirnames if d.lower() != ".svn"]
    for filename in filenames:
        if filename.endswith(extensions):
            top_files.append(os.path.abspath(os.path.join(dirpath, filename)))

# --------------------------
# 3ï¸âƒ£ root ä¸‹ã®å…¨ãƒ•ã‚¡ã‚¤ãƒ«é›†åˆï¼ˆã‚°ãƒ­ãƒ¼ãƒãƒ«é‡è¤‡é™¤å»ç”¨ï¼‰
# --------------------------
all_root_files = set()
for dirpath, dirnames, filenames in os.walk(root_dir):
    dirnames[:] = [d for d in dirnames if d.lower() != ".svn"]
    for filename in filenames:
        if filename.endswith(extensions):
            all_root_files.add(os.path.abspath(os.path.join(dirpath, filename)))

global_seen_in_root = set()  # root ä¸‹ã®ä¾å­˜ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ã‚°ãƒ­ãƒ¼ãƒãƒ«ã«ä¸€åº¦ã ã‘æ¡ç”¨ã™ã‚‹ãŸã‚ã®ã‚»ãƒƒãƒˆ

# --------------------------
# 4ï¸âƒ£ ãƒ•ã‚¡ã‚¤ãƒ«è§£æé–¢æ•°ï¼ˆ1ãƒ•ã‚¡ã‚¤ãƒ«åˆ†ã®ç›´æ¥ include ã‚’æŠ½å‡ºï¼‰
#    - .h ã«å¯¾ã—ã¦åŒå .cpp ã‚’è£œå®Œã—ã¦ includes ã«è¿½åŠ ã™ã‚‹ï¼ˆã¾ã æœªè§£æãªã‚‰æ¬¡ãƒ©ã‚¦ãƒ³ãƒ‰ã§å‡¦ç†ï¼‰
# --------------------------
def parse_file_once(full_path):
    includes_list = []
    try:
        with open(full_path, 'r', encoding='utf-8', errors='ignore') as f:
            in_block_comment = False
            for line in f:
                stripped = line.strip()
                # ãƒ–ãƒ­ãƒƒã‚¯ã‚³ãƒ¡ãƒ³ãƒˆå†…ã‹ã©ã†ã‹ã®å‡¦ç†
                if in_block_comment:
                    if '*/' in stripped:
                        in_block_comment = False
                        stripped = stripped.split('*/', 1)[1]
                    else:
                        continue
                if '/*' in stripped:
                    if '*/' in stripped:
                        stripped = re.sub(r'/\*.*?\*/', '', stripped)
                    else:
                        in_block_comment = True
                        stripped = stripped.split('/*', 1)[0]
                # è¡Œã‚³ãƒ¡ãƒ³ãƒˆé™¤å»
                stripped = re.sub(r'//.*', '', stripped).strip()
                if not stripped:
                    continue

                match = include_pattern.search(stripped)
                if not match:
                    continue
                include_file = match.group(1)

                # ã‚·ã‚¹ãƒ†ãƒ ãƒ˜ãƒƒãƒ€ã‚„çµ¶å¯¾ãƒ‘ã‚¹ã® include ã¯ç„¡è¦–
                if include_file.startswith('<') or include_file.startswith('/'):
                    continue

                # åŒãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªå„ªå…ˆã§çµ¶å¯¾ãƒ‘ã‚¹å€™è£œã‚’ä½œã‚‹
                candidate = os.path.join(os.path.dirname(full_path), include_file)
                if os.path.exists(candidate):
                    include_path = os.path.abspath(candidate)
                else:
                    basename = os.path.basename(include_file)
                    if basename in file_index and file_index[basename]:
                        include_path = file_index[basename][0]
                    else:
                        # ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆå†…ã§è¦‹ã¤ã‹ã‚‰ãªã„å ´åˆã¯ç„¡è¦–ï¼ˆå¤–éƒ¨ãƒ©ã‚¤ãƒ–ãƒ©ãƒªç­‰ï¼‰
                        continue

                # root å†…ãƒ•ã‚¡ã‚¤ãƒ«ã«ã¤ã„ã¦ã¯ã‚°ãƒ­ãƒ¼ãƒãƒ«ä¸€åº¦ã ã‘æ¡ç”¨ã™ã‚‹ãƒ«ãƒ¼ãƒ«
                if include_path in all_root_files:
                    if include_path not in global_seen_in_root:
                        global_seen_in_root.add(include_path)
                        includes_list.append(include_path)
                    else:
                        # æ—¢ã«ã‚°ãƒ­ãƒ¼ãƒãƒ«ã§è¦‹ãŸãƒ•ã‚¡ã‚¤ãƒ«ã¯é‡è¤‡ã¨ã—ã¦ã‚¹ã‚­ãƒƒãƒ—
                        continue
                else:
                    # root å¤–ã®ãƒ•ã‚¡ã‚¤ãƒ«ã¯ãã®ã¾ã¾è¿½åŠ ï¼ˆé‡è¤‡æ’é™¤ã®å¯¾è±¡å¤–ï¼‰
                    includes_list.append(include_path)

        # .h/.hpp ã«å¯¾ã—ã¦åŒåã® .cpp ã‚’è£œå®Œã™ã‚‹ï¼ˆã‚ã‚Œã°è¿½åŠ ï¼‰
        if full_path.endswith(('.h', '.hpp')):
            base = os.path.splitext(os.path.basename(full_path))[0]
            cpp_name = base + ".cpp"
            if cpp_name in file_index and file_index[cpp_name]:
                cpp_path = file_index[cpp_name][0]
                # cpp_path ãŒ root å†…ã§ã¾ã ã‚°ãƒ­ãƒ¼ãƒãƒ«æ¡ç”¨ã•ã‚Œã¦ã„ãªã‘ã‚Œã°æ¡ç”¨ã—ã¦ includes ã«è¿½åŠ 
                if cpp_path in all_root_files:
                    if cpp_path not in global_seen_in_root:
                        global_seen_in_root.add(cpp_path)
                        includes_list.append(cpp_path)
                    else:
                        # æ—¢ã«ã‚°ãƒ­ãƒ¼ãƒãƒ«ã§æ¡ç”¨æ¸ˆã¿ -> ã‚¹ã‚­ãƒƒãƒ—
                        pass
                else:
                    # root å¤–ã® cppï¼ˆç¨€ï¼‰ã‚‚è¿½åŠ 
                    includes_list.append(cpp_path)

    except Exception as e:
        print(f"âš ï¸ èª­ã¿å–ã‚Šå¤±æ•—: {full_path} - {e}")

    return full_path, includes_list

# --------------------------
# 5ï¸âƒ£ å†å¸°çš„ã«ä¸¦åˆ—è§£æã™ã‚‹ãƒ«ãƒ¼ãƒ—
#    - pending: ä»Šå›è§£æã™ã¹ããƒ•ã‚¡ã‚¤ãƒ«é›†åˆï¼ˆåˆå›ã¯ top_filesï¼‰
#    - parsed: æ—¢ã«è§£ææ¸ˆã¿ã®ãƒ•ã‚¡ã‚¤ãƒ«
#    - next_pending ã«æ–°ã—ãç™ºè¦‹ã—ãŸæœªè§£æãƒ•ã‚¡ã‚¤ãƒ«ã‚’å…¥ã‚Œã¦æ¬¡ãƒ©ã‚¦ãƒ³ãƒ‰ã¸
# --------------------------
dependency_map = {}
parsed = set()
pending = set(top_files)

print(f"ğŸ” ProjectA/src ã®ãƒˆãƒƒãƒ—ãƒ¬ãƒ™ãƒ« {len(top_files)} å€‹ã‹ã‚‰å†å¸°è§£æã‚’é–‹å§‹ã—ã¾ã™...")

with ThreadPoolExecutor(max_workers=os.cpu_count() or 4) as executor:
    round_idx = 0
    while pending:
        round_idx += 1
        pending_list = list(pending)
        pending = set()
        desc = f"è§£æãƒ©ã‚¦ãƒ³ãƒ‰ {round_idx} ({len(pending_list)} ä»¶)"
        for full_path, includes in tqdm(executor.map(parse_file_once, pending_list), total=len(pending_list), desc=desc):
            # dependency_map ã«çµæœã‚’å…¥ã‚Œã‚‹ï¼ˆä¸Šæ›¸ãã—ã¦ã‚‚å•é¡Œãªã„ï¼‰
            dependency_map[full_path] = includes
            parsed.add(full_path)

            # includes ã«å«ã¾ã‚Œã‚‹ãƒ•ã‚¡ã‚¤ãƒ«ãŒãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆå†…ã§ã¾ã è§£æã•ã‚Œã¦ã„ãªã‘ã‚Œã°æ¬¡ãƒ©ã‚¦ãƒ³ãƒ‰ã«è¿½åŠ 
            for dep in includes:
                if isinstance(dep, str) and os.path.isabs(dep) and os.path.exists(dep):
                    if dep not in parsed:
                        pending.add(dep)
        # æ¬¡ãƒ©ã‚¦ãƒ³ãƒ‰ã¸ï¼ˆpending ãŒç©ºã«ãªã‚‹ã¾ã§ç¶šãï¼‰

# --------------------------
# 6ï¸âƒ£ ãƒ„ãƒªãƒ¼ç”Ÿæˆï¼ˆä¾å­˜é–¢ä¿‚ãƒ†ãƒ¼ãƒ–ãƒ«ã¯å®Œå…¨ã«ãã‚ã£ã¦ã„ã‚‹ãŸã‚ã€å†å¸°ã§æœ€åº•å±¤ã¾ã§å±•é–‹ã§ãã‚‹ï¼‰
# --------------------------
def build_tree_lines(file_path, prefix='', visited=None):
    if visited is None:
        visited = set()
    if file_path in visited:
        return [prefix + "(å¾ªç’°ä¾å­˜)"]
    visited.add(file_path)

    lines = []
    deps = dependency_map.get(file_path, [])
    count = len(deps)
    for i, dep in enumerate(deps):
        branch = "â””â”€ " if i == count - 1 else "â”œâ”€ "
        sub_prefix = "   " if i == count - 1 else "â”‚  "
        lines.append(prefix + branch + dep)
        if dep in dependency_map:
            lines.extend(build_tree_lines(dep, prefix + sub_prefix, visited))
    visited.remove(file_path)
    return lines

# --------------------------
# 7ï¸âƒ£ TXT æ›¸ãå‡ºã—ï¼ˆç”Ÿæˆã—ãªãŒã‚‰æ›¸ãè¾¼ã¿ã€ãƒ—ãƒ­ã‚°ãƒ¬ã‚¹è¡¨ç¤ºï¼‰
# --------------------------
output_file = os.path.join(root_dir, f"{project_name}_dependencies_tree.txt")

def estimate_total_lines(dep_map, roots):
    total = 0
    def count_lines(file_path, visited=None):
        nonlocal total
        if visited is None:
            visited = set()
        if file_path in visited:
            total += 1
            return
        visited.add(file_path)
        total += 1
        for dep in dep_map.get(file_path, []):
            count_lines(dep, visited)
        visited.remove(file_path)
    for f in roots:
        if f in dep_map:
            count_lines(f)
        else:
            total += 1  # ä¾å­˜ç„¡ã—ã®ãƒˆãƒƒãƒ—ãƒ•ã‚¡ã‚¤ãƒ«ã‚‚1è¡Œã¨ã¿ãªã™
    return total

total_lines = estimate_total_lines(dependency_map, top_files)

with io.open(output_file, 'w', encoding='utf-8', buffering=1024*1024) as f:
    pbar = tqdm(total=total_lines, desc="TXT æ›¸ãè¾¼ã¿é€²è¡Œä¸­")
    for top_file in top_files:
        # ãƒˆãƒƒãƒ—ãƒ•ã‚¡ã‚¤ãƒ«ã¯ top_files ã®é †ã§å‡ºåŠ›ï¼ˆè§£æçµæœãŒãªãã¦ã‚‚å‡ºåŠ›ï¼‰
        f.write(top_file + "\n")
        pbar.update(1)
        if top_file in dependency_map:
            tree_lines = build_tree_lines(top_file)
            for line in tree_lines:
                f.write(line + "\n")
                pbar.update(1)
        f.write("\n")
        pbar.update(1)
    pbar.close()

print(f"\nâœ… {project_name} ã®ä¾å­˜ãƒ„ãƒªãƒ¼ã‚’å®Œå…¨ã«å‡ºåŠ›ã—ã¾ã—ãŸï¼š{output_file}")