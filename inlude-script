import os
import xml.etree.ElementTree as ET
from collections import defaultdict

# è§£æå•ä¸ª .vcxproj æ–‡ä»¶ï¼Œæå–ä¾èµ–ï¼ˆé™æ€åº“å’Œå¤´æ–‡ä»¶ç›®å½•ï¼‰
def parse_vcxproj(project_path):
    deps = {"libs": [], "includes": []}
    ns = {"msb": "http://schemas.microsoft.com/developer/msbuild/2003"}

    try:
        tree = ET.parse(project_path)
        root = tree.getroot()

        for item_def in root.findall(".//msb:ItemDefinitionGroup", ns):
            # é“¾æ¥åº“ä¾èµ–
            link = item_def.find("msb:Link", ns)
            if link is not None:
                libs = link.find("msb:AdditionalDependencies", ns)
                if libs is not None and libs.text:
                    for lib in libs.text.split(";"):
                        lib = lib.strip()
                        if lib and not lib.startswith("%("):
                            deps["libs"].append(lib)

            # include ç›®å½•ä¾èµ–
            cl = item_def.find("msb:ClCompile", ns)
            if cl is not None:
                inc = cl.find("msb:AdditionalIncludeDirectories", ns)
                if inc is not None and inc.text:
                    for path in inc.text.split(";"):
                        path = path.strip()
                        if path and not path.startswith("%("):
                            deps["includes"].append(path)

    except Exception as e:
        print(f"[!] Failed to parse {project_path}: {e}")

    return deps


# æ„å»ºè·¨é¡¹ç›®ä¾èµ–æ ‘
def build_dependency_tree(project, all_projects, visited=None):
    if visited is None:
        visited = set()

    project_name = os.path.splitext(os.path.basename(project))[0]
    if project_name in visited:
        return {}

    visited.add(project_name)

    deps_info = parse_vcxproj(project)
    tree = defaultdict(dict)

    # å°è¯•å°† .lib åç§°åŒ¹é…åˆ°æœ¬åœ°å…¶ä»–é¡¹ç›®
    for lib in deps_info["libs"]:
        lib_name = os.path.splitext(os.path.basename(lib))[0]
        for other_proj in all_projects:
            other_name = os.path.splitext(os.path.basename(other_proj))[0]
            if lib_name.lower() == other_name.lower():
                tree[project_name][other_name] = build_dependency_tree(other_proj, all_projects, visited)

    return tree


def print_tree(tree, indent=0):
    for k, v in tree.items():
        print("  " * indent + f"ğŸ“ {k}")
        print_tree(v, indent + 1)


if __name__ == "__main__":
    root_dir = r"D:\Projects"  # ä½ çš„æ ¹ç›®å½•
    all_projects = [
        os.path.join(dp, f)
        for dp, _, files in os.walk(root_dir)
        for f in files if f.endswith(".vcxproj")
    ]

    # ä½ å¯ä»¥ä»ä»»æ„ä¸€ä¸ªé¡¶å±‚é¡¹ç›®å¼€å§‹ï¼Œæ¯”å¦‚ AppMain
    root_project = r"D:\Projects\AppMain\AppMain.vcxproj"

    deps_tree = build_dependency_tree(root_project, all_projects)
    print_tree(deps_tree)