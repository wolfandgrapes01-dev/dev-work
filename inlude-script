import os
import xml.etree.ElementTree as ET
from collections import defaultdict

# 解析单个 .vcxproj 文件，提取依赖（静态库和头文件目录）
def parse_vcxproj(project_path):
    deps = {"libs": [], "includes": []}
    ns = {"msb": "http://schemas.microsoft.com/developer/msbuild/2003"}

    try:
        tree = ET.parse(project_path)
        root = tree.getroot()

        for item_def in root.findall(".//msb:ItemDefinitionGroup", ns):
            # 链接库依赖
            link = item_def.find("msb:Link", ns)
            if link is not None:
                libs = link.find("msb:AdditionalDependencies", ns)
                if libs is not None and libs.text:
                    for lib in libs.text.split(";"):
                        lib = lib.strip()
                        if lib and not lib.startswith("%("):
                            deps["libs"].append(lib)

            # include 目录依赖
            cl = item_def.find("msb:ClCompile", ns)
            if cl is not None:
                inc = cl.find("msb:AdditionalIncludeDirectories", ns)
                if inc is not None and inc.text:
                    for path in inc.text.split(";"):
                        path = path.strip()
                        if path and not path.startswith("%("):
                            deps["includes"].append(path)

    except Exception as e:
        print(f"[!] Failed to parse {project_path}: {e}")

    return deps


# 构建跨项目依赖树
def build_dependency_tree(project, all_projects, visited=None):
    if visited is None:
        visited = set()

    project_name = os.path.splitext(os.path.basename(project))[0]
    if project_name in visited:
        return {}

    visited.add(project_name)

    deps_info = parse_vcxproj(project)
    tree = defaultdict(dict)

    # 尝试将 .lib 名称匹配到本地其他项目
    for lib in deps_info["libs"]:
        lib_name = os.path.splitext(os.path.basename(lib))[0]
        for other_proj in all_projects:
            other_name = os.path.splitext(os.path.basename(other_proj))[0]
            if lib_name.lower() == other_name.lower():
                tree[project_name][other_name] = build_dependency_tree(other_proj, all_projects, visited)

    return tree


def print_tree(tree, indent=0):
    for k, v in tree.items():
        print("  " * indent + f"📁 {k}")
        print_tree(v, indent + 1)


if __name__ == "__main__":
    root_dir = r"D:\Projects"  # 你的根目录
    all_projects = [
        os.path.join(dp, f)
        for dp, _, files in os.walk(root_dir)
        for f in files if f.endswith(".vcxproj")
    ]

    # 你可以从任意一个顶层项目开始，比如 AppMain
    root_project = r"D:\Projects\AppMain\AppMain.vcxproj"

    deps_tree = build_dependency_tree(root_project, all_projects)
    print_tree(deps_tree)