import os
import re
from collections import defaultdict
from concurrent.futures import ThreadPoolExecutor
from tqdm import tqdm  # è¿›åº¦æ¡

root_dir = r"C:\path\to\your\root"
extensions = ('.cpp', '.c', '.h', '.hpp')
include_pattern = re.compile(r'#include\s+[<"](.+?)[>"]')

# --------------------------
# 1ï¸âƒ£ æ„å»ºæ–‡ä»¶ç´¢å¼•
# --------------------------
file_index = defaultdict(list)
for dirpath, dirnames, filenames in os.walk(root_dir):
    dirnames[:] = [d for d in dirnames if d.lower() != ".svn"]
    for filename in filenames:
        if filename.endswith(extensions):
            file_index[filename].append(os.path.abspath(os.path.join(dirpath, filename)))

# --------------------------
# 2ï¸âƒ£ æ‰¾ src æ–‡ä»¶å¤¹
# --------------------------
def find_src_dirs(root):
    src_dirs = []
    for dirpath, dirnames, _ in os.walk(root):
        dirnames[:] = [d for d in dirnames if d.lower() != ".svn"]
        for d in dirnames:
            if d.lower() == "src":
                src_dirs.append(os.path.join(dirpath, d))
    return src_dirs

# --------------------------
# 3ï¸âƒ£ æ–‡ä»¶è§£æå‡½æ•°
# --------------------------
def parse_file(full_path):
    includes = []
    try:
        with open(full_path, 'r', encoding='utf-8', errors='ignore') as f:
            in_block_comment = False
            for line in f:
                stripped = line.strip()
                # å¤šè¡Œæ³¨é‡Š
                if in_block_comment:
                    if '*/' in stripped:
                        in_block_comment = False
                        stripped = stripped.split('*/',1)[1]
                    else:
                        continue
                if '/*' in stripped:
                    if '*/' in stripped:
                        stripped = re.sub(r'/\*.*?\*/', '', stripped)
                    else:
                        in_block_comment = True
                        stripped = stripped.split('/*',1)[0]
                # å•è¡Œæ³¨é‡Š
                stripped = re.sub(r'//.*', '', stripped).strip()
                if not stripped:
                    continue

                match = include_pattern.search(stripped)
                if match:
                    include_file = match.group(1)
                    # ä¼˜å…ˆåŒç›®å½•
                    candidate = os.path.join(os.path.dirname(full_path), include_file)
                    if os.path.exists(candidate):
                        include_path = os.path.abspath(candidate)
                    else:
                        basename = os.path.basename(include_file)
                        if basename in file_index:
                            include_path = file_index[basename][0]
                        else:
                            include_path = include_file  # å¤–éƒ¨åº“æˆ–æ‰¾ä¸åˆ°
                    includes.append(include_path)
    except Exception as e:
        print(f"âš ï¸ è¯»å–å¤±è´¥: {full_path} - {e}")
    return full_path, includes

# --------------------------
# 4ï¸âƒ£ å¤šçº¿ç¨‹è§£æ src æ–‡ä»¶å¤¹ï¼ˆå®‰å…¨ tqdmï¼‰
# --------------------------
dependency_map = {}
src_dirs = find_src_dirs(root_dir)
all_files = []

for src in src_dirs:
    for dirpath, _, filenames in os.walk(src):
        for filename in filenames:
            if filename.endswith(extensions):
                all_files.append(os.path.abspath(os.path.join(dirpath, filename)))

print(f"ğŸ” æ‰¾åˆ° {len(all_files)} ä¸ªæºæ–‡ä»¶ï¼Œå¼€å§‹è§£æ...")

with ThreadPoolExecutor(max_workers=os.cpu_count() or 4) as executor:
    # ä½¿ç”¨ map + tqdmï¼Œä¿è¯è¿›åº¦æ¡èµ°å®Œè¡¨ç¤ºæ‰€æœ‰ä»»åŠ¡å®Œæˆ
    for full_path, includes in tqdm(executor.map(parse_file, all_files), total=len(all_files)):
        if includes:
            dependency_map[full_path] = includes

# --------------------------
# 5ï¸âƒ£ ç”Ÿæˆæ ‘å½¢ç»“æ„ï¼ˆé€’å½’ï¼‰
# --------------------------
def build_tree(file_path, prefix='', visited=None):
    if visited is None:
        visited = set()
    if file_path in visited:
        return [prefix + "(å¾ªç¯ä¾èµ–)"]
    visited.add(file_path)

    lines = []
    deps = dependency_map.get(file_path, [])
    count = len(deps)
    for i, dep in enumerate(deps):
        branch = "â””â”€ " if i == count - 1 else "â”œâ”€ "
        sub_prefix = "   " if i == count - 1 else "â”‚  "
        lines.append(prefix + branch + dep)
        if dep in dependency_map:
            lines.extend(build_tree(dep, prefix + sub_prefix, visited))
    visited.remove(file_path)
    return lines

# --------------------------
# 6ï¸âƒ£ è¾“å‡ºæ ‘å½¢ TXTï¼ˆæ‰¹é‡å†™å…¥ï¼Œæå‡æ€§èƒ½ï¼‰
# --------------------------
output_file = os.path.join(root_dir, "dependencies_tree.txt")

all_output_lines = []
for top_file in dependency_map:
    all_output_lines.append(top_file + "\n")
    tree_lines = build_tree(top_file)
    all_output_lines.extend(line + "\n" for line in tree_lines)
    all_output_lines.append("\n")  # é¡¶å±‚æ–‡ä»¶é—´åŠ ç©ºè¡Œ

# ä¸€æ¬¡æ€§å†™å…¥æ–‡ä»¶
with open(output_file, 'w', encoding='utf-8') as f:
    f.writelines(all_output_lines)

print(f"\nâœ… ä¾èµ–æ ‘å·²è¾“å‡ºåˆ°ï¼š{output_file}")