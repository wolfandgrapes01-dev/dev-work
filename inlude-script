import os
import re
from collections import defaultdict
from concurrent.futures import ThreadPoolExecutor
from tqdm import tqdm
import io

# --------------------------
# é…ç½®
# --------------------------
root_dir = r"C:\path\to\your\root"  # æ ¹ç›®å½•ï¼Œæ›¿æ¢ä¸ºçœŸå®è·¯å¾„
project_name = "ProjectA"            # åªåˆ†æ ProjectA
extensions = ('.cpp', '.c', '.h', '.hpp')
include_pattern = re.compile(r'#include\s+[<"](.+?)[>"]')

# --------------------------
# 1ï¸âƒ£ æ„å»ºæ–‡ä»¶ç´¢å¼•ï¼ˆroot ä¸‹æ‰€æœ‰é¡¹ç›®æ–‡ä»¶ï¼Œç”¨äºè·¨é¡¹ç›®æŸ¥æ‰¾ï¼‰
# --------------------------
file_index = defaultdict(list)
for dirpath, dirnames, filenames in os.walk(root_dir):
    dirnames[:] = [d for d in dirnames if d.lower() != ".svn"]
    for filename in filenames:
        if filename.endswith(extensions):
            file_index[filename].append(os.path.abspath(os.path.join(dirpath, filename)))

# --------------------------
# 2ï¸âƒ£ æ”¶é›† ProjectA/src é¡¶å±‚åˆ†æå¯¹è±¡
# --------------------------
project_a_src = os.path.join(root_dir, project_name, "src")
top_files = []
for dirpath, dirnames, filenames in os.walk(project_a_src):
    dirnames[:] = [d for d in dirnames if d.lower() != ".svn"]
    for filename in filenames:
        if filename.endswith(extensions):
            top_files.append(os.path.abspath(os.path.join(dirpath, filename)))

# --------------------------
# 3ï¸âƒ£ æ”¶é›† root ä¸‹æ‰€æœ‰æ–‡ä»¶ï¼ˆç”¨äºå…¨å±€ä¾èµ–å»é‡ï¼‰
# --------------------------
all_root_files = []
for dirpath, dirnames, filenames in os.walk(root_dir):
    dirnames[:] = [d for d in dirnames if d.lower() != ".svn"]
    for filename in filenames:
        if filename.endswith(extensions):
            all_root_files.append(os.path.abspath(os.path.join(dirpath, filename)))

all_root_files = set(all_root_files)
global_seen_in_root = set()  # root ä¸‹ä¾èµ–å¯¹è±¡å…¨å±€å»é‡

# --------------------------
# 4ï¸âƒ£ æ–‡ä»¶è§£æå‡½æ•°ï¼ˆè§£æä¸€ä¸ªæ–‡ä»¶çš„ç›´æ¥ includeï¼‰
#     è¿”å› (full_path, [include_abs_path1, include_abs_path2, ...])
# --------------------------
def parse_file_once(full_path):
    includes_list = []
    try:
        with open(full_path, 'r', encoding='utf-8', errors='ignore') as f:
            in_block_comment = False
            for line in f:
                stripped = line.strip()
                # å¤šè¡Œæ³¨é‡Šå¤„ç†
                if in_block_comment:
                    if '*/' in stripped:
                        in_block_comment = False
                        stripped = stripped.split('*/', 1)[1]
                    else:
                        continue
                if '/*' in stripped:
                    if '*/' in stripped:
                        # è¡Œå†…å¤šè¡Œæ³¨é‡Š
                        stripped = re.sub(r'/\*.*?\*/', '', stripped)
                    else:
                        in_block_comment = True
                        stripped = stripped.split('/*', 1)[0]
                # å•è¡Œæ³¨é‡Š
                stripped = re.sub(r'//.*', '', stripped).strip()
                if not stripped:
                    continue

                match = include_pattern.search(stripped)
                if match:
                    include_file = match.group(1)

                    # è¿‡æ»¤ç³»ç»Ÿ / angle includes
                    if include_file.startswith('<') or include_file.startswith('/'):
                        continue

                    # ä¼˜å…ˆåŒç›®å½•ç›¸å¯¹è·¯å¾„
                    candidate = os.path.join(os.path.dirname(full_path), include_file)
                    if os.path.exists(candidate):
                        include_path = os.path.abspath(candidate)
                    else:
                        basename = os.path.basename(include_file)
                        # ä½¿ç”¨ç´¢å¼•æŸ¥æ‰¾åŒåæ–‡ä»¶ï¼Œå–ç¬¬ä¸€ä¸ªåŒ¹é…
                        if basename in file_index and file_index[basename]:
                            include_path = file_index[basename][0]
                        else:
                            # æ— æ³•å®šä½åˆ°é¡¹ç›®å†…æ–‡ä»¶ -> å¿½ç•¥ï¼ˆé€šå¸¸ä¸ºç¬¬ä¸‰æ–¹æˆ–ç³»ç»Ÿï¼‰
                            continue

                    # å…¨å±€å»é‡è§„åˆ™ï¼ˆåªå¯¹ root ä¸‹æ–‡ä»¶å»é‡ï¼‰
                    if include_path in all_root_files:
                        # å¦‚æœè¿™ä¸ª root æ–‡ä»¶è¿˜æ²¡è¢«å…¨å±€è®°å½•è¿‡ï¼Œåˆ™è®°å½•å¹¶ä¿ç•™
                        if include_path not in global_seen_in_root:
                            global_seen_in_root.add(include_path)
                            includes_list.append(include_path)
                        else:
                            # å·²è¢«å…¨å±€è®°å½•è¿‡ï¼šè·³è¿‡ï¼ˆå…¨å±€å»é‡ï¼‰
                            continue
                    else:
                        # é root æ–‡ä»¶ï¼ˆä¾‹å¦‚å¤–éƒ¨ç¬¬ä¸‰æ–¹ï¼‰ï¼Œä¿ç•™ï¼Œä¸å‚ä¸å…¨å±€å»é‡
                        includes_list.append(include_path)

    except Exception as e:
        print(f"âš ï¸ è¯»å–å¤±è´¥: {full_path} - {e}")

    return full_path, includes_list

# --------------------------
# 5ï¸âƒ£ é€’å½’å¹¶å‘è§£æï¼šä» top_files å‡ºå‘ï¼Œé€’å½’è§£ææ‰€æœ‰å¯è¾¾æ–‡ä»¶
#    é€»è¾‘ï¼š
#      - pending = set(top_files)
#      - while pending not empty:
#           å¹¶å‘è§£æ pending ä¸­æ‰€æœ‰æ–‡ä»¶ -> å¾—åˆ°å„è‡ª includes
#           æŠŠè§£æç»“æœåŠ å…¥ dependency_map
#           å¯¹æ¯ä¸ª includeï¼Œå¦‚æœæ˜¯æœ¬åœ°å­˜åœ¨æ–‡ä»¶ä¸”æœªè§£æè¿‡ -> åŠ å…¥ next_pending
#           pending = next_pending
# --------------------------
dependency_map = {}   # file_abs_path -> [dep_abs_path,...]
parsed = set()        # å·²ç»è§£æè¿‡ï¼ˆé¿å…é‡å¤è§£æï¼‰

# é¦–è½®å¾…è§£æï¼šé¡¶å±‚æ–‡ä»¶ï¼ˆä»… ProjectA/srcï¼‰
pending = set(top_files)

print(f"ğŸ” å°†é€’å½’è§£æ {len(pending)} ä¸ªé¡¶å±‚æ–‡ä»¶åŠå…¶å¯è¾¾ä¾èµ–ï¼ˆå¹¶å‘è§£æï¼‰...")

with ThreadPoolExecutor(max_workers=os.cpu_count() or 4) as executor:
    # é€è½®å¹¶å‘è§£æï¼Œç›´åˆ°æ²¡æœ‰æ–°çš„å¾…è§£ææ–‡ä»¶
    while pending:
        pending_list = list(pending)
        pending = set()
        # map è¿”å›ç»“æœæŒ‰è¿­ä»£é¡ºåºï¼Œä½¿ç”¨ tqdm å±•ç¤ºæœ¬è½®è¿›åº¦
        for full_path, includes in tqdm(executor.map(parse_file_once, pending_list),
                                       total=len(pending_list), desc="è§£æè½®"):
            # è®°å½•è§£æç»“æœï¼ˆä¿æŒé¡ºåºï¼‰
            dependency_map[full_path] = includes
            parsed.add(full_path)

            # å¯¹æ¯ä¸ª includeï¼Œå¦‚æœæ˜¯æœ¬åœ°å­˜åœ¨æ–‡ä»¶ï¼Œä¸”è¿˜æœªè§£æè¿‡ï¼ŒåŠ å…¥ä¸‹ä¸€è½®
            for dep in includes:
                # dep å·²æ˜¯ç»å¯¹è·¯å¾„å®šä½åˆ°é¡¹ç›®å†…æ–‡ä»¶ï¼ˆparse_file_once å·²ç¡®ä¿ï¼‰
                if isinstance(dep, str) and os.path.isabs(dep) and os.path.exists(dep):
                    if dep not in parsed:
                        pending.add(dep)
        # ä¸‹ä¸€è½®ç»§ç»­ï¼Œç›´åˆ° pending ç©º

# --------------------------
# 6ï¸âƒ£ æ ‘å½¢ç”Ÿæˆï¼ˆé€’å½’ï¼‰â€”â€”ç°åœ¨ dependency_map å·²åŒ…å«å¯è¾¾æ–‡ä»¶ï¼Œé€’å½’å¯å±•å¼€åˆ°åº•å±‚
# --------------------------
def build_tree_lines(file_path, prefix='', visited=None):
    if visited is None:
        visited = set()
    if file_path in visited:
        return [prefix + "(å¾ªç¯ä¾èµ–)"]
    visited.add(file_path)

    lines = []
    deps = dependency_map.get(file_path, [])
    count = len(deps)
    for i, dep in enumerate(deps):
        branch = "â””â”€ " if i == count - 1 else "â”œâ”€ "
        sub_prefix = "   " if i == count - 1 else "â”‚  "
        lines.append(prefix + branch + dep)
        # åªæœ‰å½“ dep è¢«è§£æè¿‡å¹¶å­˜åœ¨ dependency_map æ—¶ï¼Œé€’å½’å±•å¼€å…¶å­ä¾èµ–
        if dep in dependency_map:
            lines.extend(build_tree_lines(dep, prefix + sub_prefix, visited))
    visited.remove(file_path)
    return lines

# --------------------------
# 7ï¸âƒ£ å†™å…¥ TXTï¼ˆè¾¹ç”Ÿæˆè¾¹å†™å…¥ï¼Œä½å†…å­˜ + tqdmï¼‰
# --------------------------
output_file = os.path.join(root_dir, f"{project_name}_dependencies_tree.txt")

# é¢„ä¼°æ€»è¡Œæ•°ï¼ˆç”¨äºè¿›åº¦æ¡ï¼‰
def estimate_total_lines(dep_map):
    total = 0
    def count_lines(file_path, visited=None):
        nonlocal total
        if visited is None:
            visited = set()
        if file_path in visited:
            total += 1
            return
        visited.add(file_path)
        total += 1
        for dep in dep_map.get(file_path, []):
            count_lines(dep, visited)
        visited.remove(file_path)
    for f in dep_map:
        count_lines(f)
    return total

total_lines = estimate_total_lines(dependency_map)

with io.open(output_file, 'w', encoding='utf-8', buffering=1024*1024) as f:  # 1MB ç¼“å†²
    pbar = tqdm(total=total_lines, desc="å†™å…¥ TXT è¿›åº¦")
    for top_file in top_files:
        # åªè¾“å‡ºä½ å…³å¿ƒçš„ ProjectA é¡¶å±‚æ–‡ä»¶ï¼ˆæŒ‰åŸå§‹ top_files åˆ—è¡¨ï¼‰
        if top_file not in dependency_map:
            # å³ä½¿æŸäº›é¡¶å±‚æ–‡ä»¶æ²¡æœ‰ä¾èµ–ï¼Œä¹Ÿå†™å‡ºå®ƒè‡ªå·±
            f.write(top_file + "\n")
            pbar.update(1)
            f.write("\n")
            pbar.update(1)
            continue

        f.write(top_file + "\n")
        pbar.update(1)
        tree_lines = build_tree_lines(top_file)
        for line in tree_lines:
            f.write(line + "\n")
            pbar.update(1)
        f.write("\n")
        pbar.update(1)
    pbar.close()

print(f"\nâœ… ProjectA ä¾èµ–æ ‘å·²è¾“å‡ºåˆ°ï¼š{output_file}")