import os
import re

root_dir = r"C:\path\to\your\root"
extensions = ('.cpp', '.c', '.h', '.hpp')
include_pattern = re.compile(r'#include\s+[<"](.+?)[>"]')

# æ–‡ä»¶ç›´æ¥ä¾èµ–è¡¨
# {æ–‡ä»¶ç»å¯¹è·¯å¾„: [ä¾èµ–å¯¹è±¡ç»å¯¹è·¯å¾„åˆ—è¡¨]}
dependency_map = {}

# --------------------------
# 1ï¸âƒ£ æ‰¾ src æ–‡ä»¶å¤¹
# --------------------------
def find_src_dirs(root):
    src_dirs = []
    for dirpath, dirnames, _ in os.walk(root):
        dirnames[:] = [d for d in dirnames if d.lower() != ".svn"]
        for d in dirnames:
            if d.lower() == "src":
                src_dirs.append(os.path.join(dirpath, d))
    return src_dirs

# --------------------------
# 2ï¸âƒ£ åˆ†æ includeï¼ˆå»é™¤æ³¨é‡Šï¼Œè¡¥å…¨è·¯å¾„ï¼‰
# --------------------------
def analyze_includes(src_dir):
    for dirpath, dirnames, filenames in os.walk(src_dir):
        dirnames[:] = [d for d in dirnames if d.lower() != ".svn"]

        for filename in filenames:
            if not filename.endswith(extensions):
                continue

            full_path = os.path.abspath(os.path.join(dirpath, filename))
            includes = []

            try:
                with open(full_path, 'r', encoding='utf-8', errors='ignore') as f:
                    in_block_comment = False
                    for line in f:
                        stripped = line.strip()

                        # å¤šè¡Œæ³¨é‡Šå¤„ç†
                        if in_block_comment:
                            if '*/' in stripped:
                                in_block_comment = False
                                stripped = stripped.split('*/',1)[1]
                            else:
                                continue

                        if '/*' in stripped:
                            if '*/' in stripped:
                                stripped = re.sub(r'/\*.*?\*/', '', stripped)
                            else:
                                in_block_comment = True
                                stripped = stripped.split('/*',1)[0]

                        # å•è¡Œæ³¨é‡Š
                        stripped = re.sub(r'//.*', '', stripped).strip()
                        if not stripped:
                            continue

                        match = include_pattern.search(stripped)
                        if match:
                            include_file = match.group(1)

                            # ä¼˜å…ˆæŸ¥æ‰¾åŒç›®å½•
                            candidate = os.path.join(dirpath, include_file)
                            if os.path.exists(candidate):
                                include_path = os.path.abspath(candidate)
                            else:
                                # åœ¨æ•´ä¸ªæ ¹ç›®å½•æœç´¢
                                include_path = None
                                for root, subdirs, files in os.walk(root_dir):
                                    subdirs[:] = [d for d in subdirs if d.lower() != ".svn"]
                                    if os.path.basename(include_file) in files:
                                        include_path = os.path.abspath(os.path.join(root, include_file))
                                        break
                                # å¦‚æœæ²¡æ‰¾åˆ°ï¼Œä¿ç•™æºç å†™æ³•
                                if include_path is None:
                                    include_path = include_file

                            includes.append(include_path)

                if includes:
                    dependency_map[full_path] = includes

            except Exception as e:
                print(f"âš ï¸ è¯»å–å¤±è´¥: {full_path} - {e}")

# --------------------------
# 3ï¸âƒ£ ç”Ÿæˆæ ‘å½¢ç»“æ„
# --------------------------
def build_tree(file_path, prefix='', visited=None):
    if visited is None:
        visited = set()
    lines = []
    if file_path in visited:
        lines.append(prefix + "(å¾ªç¯ä¾èµ–)")
        return lines
    visited.add(file_path)

    if file_path not in dependency_map:
        return lines

    deps = dependency_map[file_path]
    count = len(deps)
    for i, dep in enumerate(deps):
        branch = "â””â”€ " if i == count - 1 else "â”œâ”€ "
        sub_prefix = "   " if i == count - 1 else "â”‚  "

        lines.append(prefix + branch + dep)

        # é€’å½’ï¼šå¦‚æœä¾èµ–å¯¹è±¡åœ¨ dependency_map ä¸­ï¼Œç»§ç»­ç”Ÿæˆå­æ ‘
        if dep in dependency_map:
            lines.extend(build_tree(dep, prefix + sub_prefix, visited.copy()))

    return lines

# --------------------------
# ä¸»æµç¨‹
# --------------------------
src_dirs = find_src_dirs(root_dir)
print(f"ğŸ” æ‰¾åˆ° {len(src_dirs)} ä¸ª src æ–‡ä»¶å¤¹ã€‚")

for src in src_dirs:
    print(f"  â†’ åˆ†æ {src}")
    analyze_includes(src)

# --------------------------
# è¾“å‡ºæ ‘å½¢ txt
# --------------------------
output_file = os.path.join(root_dir, "dependencies_tree.txt")
with open(output_file, 'w', encoding='utf-8') as f:
    for top_file in dependency_map:
        f.write(top_file + "\n")
        tree_lines = build_tree(top_file, '')
        for line in tree_lines:
            f.write(line + "\n")
        f.write("\n")

print(f"\nâœ… ä¾èµ–æ ‘å·²è¾“å‡ºåˆ°ï¼š{output_file}")