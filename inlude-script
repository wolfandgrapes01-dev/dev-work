import os
import re
from collections import defaultdict

# 匹配 #include "xxx.h" 或 #include <xxx.h>
INCLUDE_RE = re.compile(r'#include\s*["<](.*?)[">]')

def is_system_include(path):
    """过滤系统头文件"""
    system_keywords = [
        "Windows Kits", "Microsoft Visual Studio", "Program Files",
        "VC\\include", "ucrt", "cstddef", "iostream", "string", "vector",
        "memory", "map", "set", "unordered", "algorithm"
    ]
    return any(k.lower() in path.lower() for k in system_keywords)

def collect_includes(root):
    """扫描整个目录并收集 include 关系"""
    includes = defaultdict(set)
    all_files = {}  # 文件名（不带路径） -> 绝对路径

    # 1️⃣ 先收集所有文件
    for dirpath, _, filenames in os.walk(root):
        for f in filenames:
            if f.endswith((".cpp", ".h", ".hpp")):
                full_path = os.path.abspath(os.path.join(dirpath, f))
                all_files[f] = full_path

    # 2️⃣ 扫描 include 关系
    for file_path in all_files.values():
        try:
            with open(file_path, encoding="utf-8", errors="ignore") as file:
                for line in file:
                    match = INCLUDE_RE.search(line)
                    if match:
                        inc = match.group(1).strip()
                        if not is_system_include(inc):
                            includes[file_path].add(inc)
        except Exception:
            pass

    # 3️⃣ 将 include 名解析为实际路径（同名匹配）
    resolved = []
    for src, incs in includes.items():
        for inc in incs:
            name = os.path.basename(inc)
            if name in all_files:
                resolved.append((src, all_files[name]))
            else:
                # 若没找到匹配文件，也输出原始 include 以备检查
                resolved.append((src, inc))
    return resolved


if __name__ == "__main__":
    root_dir = os.getcwd()  # 当前目录作为根目录
    deps = collect_includes(root_dir)

    print("=== 文件依赖关系列表（完整路径） ===")
    for src, dep in deps:
        print(f"{src} -> {dep}")